const fs = require('fs');
const esbuild = require('esbuild');
const htmlmin = require('html-minifier-terser');
const markdown = require('markdown-it')({ html: true });
const music = require('music-metadata');
const prettydata = require('pretty-data');
const yaml = require('js-yaml');
const postcss = require('postcss');
const postcssImport = require('postcss-import');
const postcssMediaMinmax = require('postcss-media-minmax');
const autoprefixer = require('autoprefixer');
const postcssCsso = require('postcss-csso');

module.exports = (config) => {

	// CSS

	const styles = [
		'./src/styles/index.css',
	];

	config.addTemplateFormats('css');

	config.addExtension('css', {
		outputFileExtension: 'css',
		compile: async (content, path) => {
			if (!styles.includes(path)) {
				return;
			}

			return async () => {
				let output = await postcss([
					postcssImport,
					postcssMediaMinmax,
					autoprefixer,
					postcssCsso,
				]).process(content, {
					from: path,
				});

				return output.css;
			}
		}
	});

	config.addNunjucksAsyncFilter('css', (path, callback) => {
		fs.readFile(path, 'utf8', (error, content) => {
			postcss([
				postcssImport,
				postcssMediaMinmax,
				autoprefixer,
				postcssCsso,
			]).process(content, {
				from: path,
			}).then((output) => {
				callback(null, output.css)
			});
		});
	});

	// JavaScript

	config.addTemplateFormats('js');

	config.addExtension('js', {
		outputFileExtension: 'js',
		compile: async (content, path) => {
			if (path !== './src/scripts/index.js') {
				return;
			}

			return async () => {
				let output = await esbuild.build({
					target: 'es2020',
					entryPoints: [path],
					minify: true,
					bundle: true,
					write: false,
				});

				return output.outputFiles[0].text;
			}
		}
	});

	// OLD

	config.addDataExtension('yml', (contents) => {
		return yaml.load(contents);
	});

	config.addPairedShortcode('markdown', (content) => {
		return markdown.render(content);
	});

	config.addFilter('length', (path) => {
		const stats = fs.statSync(path);

		return stats.size;
	});

	const getDuration = (path) => {
		return music.parseFile(path)
			.then(metadata => {
				const duration = parseFloat(metadata.format.duration);
				return new Date(Math.ceil(duration) * 1000).toISOString().substring(11, 19);
			})
			.catch(error => {
				console.log(error);
			});
	}

	config.addNunjucksAsyncFilter('duration', async (path, callback) => {
		const duration = await getDuration(path);

		callback(null, duration);
	});

	const htmlminSettings = {
		collapseBooleanAttributes: true,
		collapseWhitespace: true,
		decodeEntities: true,
		includeAutoGeneratedTags: false,
		removeComments: true,
		sortClassName: true,
	}

	config.addFilter('htmlmin', async (value) => {
		return await htmlmin.minify(
			value,
			htmlminSettings,
		);
	});

	config.addTransform('htmlmin', (content, outputPath) => {
		if(outputPath && outputPath.endsWith('.html')) {
			const result = htmlmin.minify(
				content,
				htmlminSettings,
			);

			return result;
		}

		return content;
	});

	config.addTransform('xmlmin', (content, outputPath) => {
		if(outputPath && outputPath.endsWith('.xml')) {
			return prettydata.pd.xmlmin(content);
		}

		return content;
	});

	// Passthrough copy

	[
		'src/favicon.ico',
		'src/fonts',
		'src/images',
		'src/episodes/**/*.(jpg|mp3)',
	].forEach(
		path => config.addPassthroughCopy(path)
	);

	return {
		dir: {
			input: 'src',
			output: 'dist',
			includes: 'includes',
			layouts: 'layouts',
			data: 'data',
		},
		dataTemplateEngine: 'njk',
		markdownTemplateEngine: 'njk',
		htmlTemplateEngine: 'njk',
		passthroughFileCopy: true,
		templateFormats: [
			'md', 'njk'
		],
	};
};
